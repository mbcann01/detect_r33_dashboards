{
  "hash": "6e0318a13b416d10235dd82ee5f13cb8",
  "result": {
    "engine": "knitr",
    "markdown": "Total patients seen by clinicians: 8003\nTotal eligible appointments: 9121  \nTotal screened appointments: 5210\nTotal screened patients that will be contacted for recruitment: 4863\nTotal recruited patients that will be interviewed: 180\n\nThe details for the variables created using this file are contained here: <https://uthtmc.sharepoint.com/:w:/r/sites/SPHDETECT-RPC/Shared%20Documents/DETECT-RPC%20R61%20R33%202022/0_data_folders/02_dashboards/00_documentation/03_r33_dashboards_implementation_planning_notes.docx.docx?d=we1c72482657342aea35ede2de4e980a0&csf=1&web=1&e=nUY12K>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'dplyr' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(here)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'here' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at C:/Users/ebiek/OneDrive - UTHealth Houston/Cannell lab/r33_dashboards\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyr, include.only = c(\"separate_wider_delim\", \"crossing\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'tidyr' was built under R version 4.3.2\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ids)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'ids' was built under R version 4.3.3\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(randomNames)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'randomNames' was built under R version 4.3.3\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(generator, include.only = \"r_phone_numbers\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'generator' was built under R version 4.3.3\n```\n\n\n:::\n:::\n\n\n# Clinician Screening Tracker Data\n## Unique MRNs and Dyad IDs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Dyad IDs\nset.seed(123)\ndyad_id <- ids::random_id(8003, 3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine MRNs and Dyad IDs\nmrn_dyad_ids <- data.frame(mrn, dyad_id, mrn_dyad_join = c(1:8003))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# MRN Dyad join column for full mock data\n\nset.seed(1)\nmrn_dyad_join_data <- sample(\n  c(1:8003, sample(c(1:8003), size = (13158 - 8003), replace = TRUE)))\n```\n:::\n\n\n## Visit dates\n\n\n\n\n## Physician and clinics\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Physician join column for full mock data\n\nset.seed(2)\nphys_join_data <- sample(\n  c(1:68, sample(c(1:68), size = (13158 - 68), replace = TRUE)))\n```\n:::\n\n\n## Screened assignments\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(23)\n# 2906 of all 5087 eligible patients are screened\nscreened_op <- sample(c(rep(1, 2001), sample(c(0,1), size = 11157, replace = TRUE)))\n```\n:::\n\n\n## Create full mock data set\n\n### Add ids, clinician data and appointment times\n\n\n\n\n\n### Add eligibility and screened status\n\n::: {.cell}\n\n```{.r .cell-code}\nclin_data <- data_app %>% \n  group_by(mrn) %>%\n  arrange(visit_date) %>%\n  mutate(\n    visit_no = row_number(),\n    # Arbitrarily assign eligibility for alternating visits (odd vs even)\n    eligible = case_when(\n      visit_no %% 2 == 1  ~ 1,\n      visit_no %% 2 == 0  ~ 0\n    )\n  ) %>% \n  ungroup() %>%\n  mutate(\n    screened = case_when(\n      eligible == 1 ~ screened_op,\n      TRUE          ~ NA\n    )\n  )\n```\n:::\n\n\n\n# Recruiting and Scheduling Tracker\n\n## Screened Patients to be Recruited\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create call date times (weekdays only)\ndates <- data.frame(dates = seq(as.Date('2026-09-01'), as.Date('2027-05-30'), by = \"day\")) \ntimes <- c(paste0(9:17, \":00:00\"), paste0(9:17, \":30:00\"), paste0(9:17, \":15:00\"))\n\nweekends <- c(\"Saturday\", \"Sunday\")\n\n# create combinations of data and time, de-duplicate and sort\ncall_date_time <- tidyr::crossing(dates, data.frame(times)) %>% \n  mutate(\n    call_date_time = as.POSIXct(paste0(dates, times))\n  ) %>% select(call_date_time) %>%\n  # Filter out weekends\n  filter(!weekdays(call_date_time) %in% weekends) %>%\n  slice(1:rec_n) %>%\n  mutate(\n    join_id = 1:rec_n\n)\n```\n:::\n\n\n\n## Create recruiter IDs\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_rec <- paste0(\"rec\", 1:4)\n\nrec_id <- sample(c(rep(all_rec, 60), sample(x = all_rec, size = (rec_n-240), replace = TRUE)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_data <- scr_pat %>% right_join(., call_date_time, by = 'join_id') %>%\n  mutate(\n    rec_id = rec_id\n  ) %>% arrange(call_date_time)\n```\n:::\n\n\n## Create mock data for each call log variable\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_op <- function(options){\n  sample(options, size = rec_n, replace = TRUE)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Answered status\nset.seed(4)\nanswered <- sample(c(rep(\"No answer/ busy sign\", 750), rep(\"Participant answered\", 953), rep(\"Voicemail\", 904),\n              rep(\"Wrong number\", 124), rep(\"Someone else answered\", 753)), size = rec_n, replace = TRUE)\n\n# Phone numbers\nset.seed(3)\nparticipant_phone_number <- r_phone_numbers(n = rec_n)\n\n# Text box mock entries\nset.seed(1)\nother_op <- sample(c(paste0(\"Some explanation_\",1:10 ), paste0(\"Another explanation_\", 1:18),                        \n                     paste0(\"A different explanation_\", 1:7)), size = rec_n, replace = TRUE)\n\n# Comments mock entries\nset.seed(2)\ncomments <- sample(c(paste0(\"Some comment_\",1:10 ), paste0(\"Another comment_\", 1:18), \n                      paste0(\"A different comment_\", 1:7), rep(NA, 3005)), size = rec_n, replace = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\ncall_data <- data.frame(rec_data, participant_phone_number, answered) %>%\n  mutate(\n    left_message = case_when(\n      answered == \"No answer/ busy sign\" ~ sample_op(\n        c(\"Left message\", \"Unable to leave message\")), \n      answered == \"Voicemail\"            ~ sample_op(\n        c(\"Left message\", \"Unable to leave message\")),\n      TRUE                               ~ NA\n    ),\n    no_message = case_when(\n      left_message == \"Unable to leave message\" ~ sample_op(\n        c(\"Voicemail box is full\", \"No voicemail box set up\", \"Other\")),\n      TRUE                 ~ NA\n    ),\n    no_message_other = case_when(\n      no_message == \"Other\" ~ other_op,\n      TRUE                  ~ NA\n    ),\n    answered_someone_else = case_when(\n      answered == \"Someone else answered\" ~ sample_op(\n        c(\"A spouse or partner\", \"An ex spouse or partner\", \n          \"A parent or step-parent\",\n          \"A brother or sister\", \"A son or daughter\", \"Another relative\", \n          \"A coworker\", \"A neighbor\", \"A friend\", \"Some other non-relative\", \n          \"Donâ€™t know\")\n      ),\n      TRUE                                ~ NA\n    ),\n    participant_contacted = case_when(\n      answered == \"Someone else answered\" ~ sample_op(\n        c(\"Participant contacted\", \"Participant not contacted\")),\n      TRUE                                ~ NA\n    ),\n    pc_no_result = case_when(\n      participant_contacted == \"Participant not contacted\" ~ sample_op(\n        c(\"Scheduled call back\", \"Unable to schedule callback\")\n      ),\n      TRUE                          ~ NA\n    ),\n    call_back_date_time = case_when(\n      pc_no_result == \"Scheduled call back\" ~ call_date_time + lubridate::days(2),\n      TRUE                                  ~ NA\n    ),\n    # Remove weekends\n    call_back_date_time = case_when(weekdays(call_back_date_time) %in% weekends ~ \n      call_back_date_time + lubridate::days(2),\n      TRUE ~ call_back_date_time),\n    call_back_phone_number = case_when(\n      pc_no_result == \"Scheduled call back\" ~ participant_phone_number,\n      TRUE                                  ~ NA \n    ),\n    call_back_no = case_when(\n      pc_no_result == \"Unable to schedule callback\" ~ sample_op(\n        c(\"Person refused\", \"Language barrier\", \"Person hung up\",\n          \"Participant impaired or disabled\", \"Participant deceased\",\n          \"Participant not available\", \"Other\")\n      ),\n      TRUE                                          ~ NA\n    ),\n    call_back_no_other = case_when(\n      call_back_no == \"Other\" ~ other_op,\n      TRUE                    ~ NA\n    ),\n    pc_yes_result = case_when(\n      answered == \"Participant answered\" | \n        participant_contacted == \"Participant contacted\" ~ \n        sample_op(\n          c(\"Interview scheduled\", \"Interview not scheduled\")\n        )\n    ),\n    interview_not_scheduled = case_when(\n      pc_yes_result == \"Interview not scheduled\" ~ sample_op(\n        c(\"Participant refused/ hung up\", \"Participant is not eligible\")\n      ),\n      TRUE                                       ~ NA\n    ),\n    ineligible = case_when(\n      interview_not_scheduled == \"Participant is not eligible\" ~ sample_op(\n        c(\"Cannot speak/read English or Spanish\", \n          \"Unwilling/unable to give consent\")\n      ),\n      TRUE                                                     ~ NA\n    ),\n    comments = comments\n  ) %>% select(-c(join_id))\n```\n:::\n\n\n\n## Create a df with 1800 unique participants \n- 360 is 20% of this \n- Each participant in a previous call log was called an average of 1.7 times.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split the data in half so that the first half has 1800 patients and a sample of the second half will have 1260\nsecond_call <- call_data %>%\n  mutate(\n    second_call = case_when(\n      pc_no_result == \"Scheduled call back\" ~ 1,\n      answered == \"No answer/ busy sign\"    ~ 1,\n      TRUE                                  ~ 0\n    )\n  )\n\n# Filter 1260 participants for a second call and 540 of that (1800 - 1260) for only one call.\nset.seed(6)\nscall_y <- second_call %>% filter(second_call == 1) %>% slice_sample(n = 1260)\nscall_n <- second_call %>% filter(second_call == 0) %>% slice_sample(n = 540) \n\n# Dyad_ids for participants that will receive a second call\nscall_y_id <- scall_y %>% select(dyad_id, call_back_date_time, call_date_time) %>% \n  rename(new_id = dyad_id, \n         new_call_time = call_back_date_time,\n         first_call_time = call_date_time)\n\n# Calls that will be converted to second calls\nyes_call <- second_call %>% \n  filter(second_call == 0 & !(dyad_id %in% scall_n$dyad_id)) %>% \n  slice_sample(n = 1260) %>% cbind(., scall_y_id) %>%\n  # Set call time to be call back time of first call and set new id to dyad id\n  mutate(\n    dyad_id = new_id,\n    call_date_time = case_when(\n      is.na(new_call_time) == FALSE ~ new_call_time,\n      TRUE                          ~ first_call_time + lubridate::days(3)\n    ),\n    # Remove weekends\n    call_date_time = case_when(weekdays(call_date_time) %in% weekends ~ \n      call_date_time + lubridate::days(2),\n      TRUE ~ call_date_time)\n  ) %>%\n  select(-c(new_id, new_call_time, first_call_time))\n  \n\nrec_raw_data <- rbind(scall_y, scall_n, yes_call) %>% arrange(call_date_time) %>% select(-c(second_call))\n```\n:::\n\n\n# Save data\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save clinician tracking data\nsaveRDS(clin_data, here::here(\"data\", \"clinician_tracker_mock_data_raw.rds\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save recruitment and scheduling data\nsaveRDS(rec_raw_data, here::here(\"data\", \"recruitment_and_scheduling_mock_data_raw.rds\"))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}